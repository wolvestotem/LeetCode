分析与第 53（和最大子数组） 题的差异

求乘积的最大值，示例中负数的出现，告诉我们这题和 53 题不一样了，**一个正数乘以负数就变成负数，即：最大值乘以负数就变成了最小值；因此：最大值和最小值是相互转换的，这一点提示我们可以把这种转换关系设计到「状态转移方程」里去；**
如何解决这个问题呢？这里常见的技巧是在「状态设计」的时候，**在原始的状态设计后面多加一个维度**，减少分类讨论，降低解决问题的难度。
**类似于股票问题，加入当前持有还是没有持有状态**

第 1 步：状态设计（特别重要）

    dp[i][j]：以 nums[i] 结尾的连续子数组的最值，计算最大值还是最小值由 j 来表示，j 就两个值；
        当 j = 0 的时候，表示计算的是最小值；
        当 j = 1 的时候，表示计算的是最大值。
这样一来，状态转移方程就容易写出。

第 2 步：推导状态转移方程（特别重要）

由于状态的设计 **nums[i] 必须被选取**（请大家体会这一点，这一点恰恰好也是使得子数组、子序列问题更加简单的原因：当情况复杂、分类讨论比较多的时候，需要固定一些量，以简化计算）；

nums[i] 的正负和之前的状态值（正负）就产生了联系，由此关系写出状态转移方程：
    当 nums[i] > 0 时，由于是乘积关系：
        最大值乘以正数依然是最大值；
        最小值乘以同一个正数依然是最小值；
    当 nums[i] < 0 时，依然是由于乘积关系：
        最大值乘以负数变成了最小值；
        最小值乘以同一个负数变成最大值；
    当 nums[i] = 0 的时候，由于 nums[i] 必须被选取，最大值和最小值都变成 0 ，合并到上面任意一种情况均成立。

但是，还要注意一点，之前状态值的正负也要考虑：例如，在考虑最大值的时候，当 nums[i] > 0 是，如果 dp[i - 1][1] < 0 （之前的状态最大值） ，此时 nums[i] 可以另起炉灶（这里依然是第 53 题的思想），此时 dp[i][1] = nums[i] ，合起来写就是：

dp[i][1] = max(nums[i], nums[i] * dp[i - 1][1]) if nums[i] >= 0

其它三种情况可以类似写出，状态转移方程如下：

```java
dp[i][0] = min(nums[i], nums[i] * dp[i - 1][0]) if nums[i] >= 0
dp[i][1] = max(nums[i], nums[i] * dp[i - 1][1]) if nums[i] >= 0

dp[i][0] = min(nums[i], nums[i] * dp[i - 1][1]) if nums[i] < 0
dp[i][1] = max(nums[i], nums[i] * dp[i - 1][0]) if nums[i] < 0
```

第 3 步：考虑初始化

由于 nums[i] 必须被选取，那么 dp[i][0] = nums[0]，dp[i][1] = nums[0]。

第 4 步：考虑输出
题目问连续子数组的乘积最大值，这些值需要遍历 dp[i][1] 获得。

**我的总结**、
应该注意最优子结构还可以是以i结尾的最优子问题。
`subarray`子串，子数组这类问题的最优子结构选择结尾方式居多，子序列问题也可以选择结尾表达，但是需要多阶递推，而子串为题只需要一阶递推关系。
明确最优子结构后，**应该注意到最大值和最小值对于正负号的不同，所以将两个最值都作为状态。和股票问题类似**
本题特有问题，可以选择抛弃之前的，直选当前项，应该考虑到。
随后的输出要非常明确table含义，应当遍历取最大值作为输出。